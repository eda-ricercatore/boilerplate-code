%	This is written by Zhiyang Ong to document data structures that I have implemented for my C++ -based boilerplate code repository.

%	The MIT License (MIT)

%	Copyright (c) <2014> <Zhiyang Ong>

%	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

%	The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

%	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

%	Email address: echo "cukj -wb- 23wU4X5M589 TROJANS cqkH wiuz2y 0f Mw Stanford" | awk '{ sub("23wU4X5M589","F.d_c_b. ") sub("Stanford","d0mA1n"); print $5, $2, $8; for (i=1; i<=1; i++) print "6\b"; print $9, $7, $6 }' | sed y/kqcbuHwM62z/gnotrzadqmC/ | tr 'q' ' ' | tr -d [:cntrl:] | tr -d 'ir' | tr y "\n"

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Graph Data Structures}
\label{sec:GraphDataStructures}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Graph Theory}
\label{ssec:GraphTheory}

A {\bf graph} $G$ is an ordered pair, $G = (V,E)$, of a vertex/node set $V$ and an edge set $E$\cite{WikipediaContributors2018a38}. \\

We denote the number of vertices, or the cardinality of the vertex/node set, as $n = |V|$. Likewise, we denote the number of edges, or the cardinality of the edge set, as $ m = |E|$ \cite[\S52.2, pp. 845]{Goldman2008}. \\

Types of {\bf finite graphs} \cite{WikipediaContributors2018a38}: \vspace{-0.2cm}
\begin{enumerate} \itemsep -4pt
\item {\bf undirected graph} \cite{WikipediaContributors2018a38}: \vspace{-0.2cm}
	\begin{enumerate} \itemsep -2pt
	\item {\bf simple graph}, or {\bf undirected simple finite graph} \cite{WikipediaContributors2018a38}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -1pt
		\item Does not allow {\bf multiple edges} (or, {\bf parallel edges}, or {\bf multi-edges}) between any pair of vertices/nodes in the graph, nor {\bf (self-)loops}.
		\item A {\bf symmetric loopless directed graph} is a graph that has an edge $(v_{2}, v_{1})$ for each edge $(v_{1}, v_{2})$, and it does not contain any self-loops (i.e., edges $v_{i}, v_{i}, \forall i \in V$).
		\item Therefore, the edges of a simple graph form a set, as opposed to multigraphs that have multisets of edges.
		\item An edge is a two-element subset of $V$; other graphs (i.e., hypergraphs) can have edges with more than two nodes.
		\end{enumerate}
	\item {\bf multigraph} \cite{WikipediaContributors2018a39}: \vspace{-0.2cm}
		\begin{enumerate} %\itemsep -1pt
		\item A {\bf multigraph} allows {\bf multiple edges} (or, {\bf parallel edges}, or {\bf multi-edges}) to exist between any pair of vertices (or, nodes) in the graph. Alternatively, for any pair of vertices (or, nodes) in the multigraph, they allow multiple edges to be incident to them \cite{WikipediaContributors2018a39}. \cite[\S13.1, pp. 596]{Goodrich2011} uses a {\bf collection} to represent the {\bf group of edges}. I prefer the term {\bf multiset}, {\bf bag}, or {\bf mset}; see \url{https://en.wikipedia.org/wiki/Multiset}.
		\item {\bf pseudograph} \cite{WikipediaContributors2018a39}: \vspace{-0.1cm}
			\begin{itemize} \itemsep -1pt
			\item Some authors/people use pseudographs and multigraphs interchangeably/synonymously.
			\item Other people use pseudographs to refer to multigraphs that allow self-loops \cite[\S B.4, pp. 1168]{Cormen2009} (or loops) \cite{WikipediaContributors2017a13}.
			\end{itemize}
		\item A {\bf planar graph} remains planar, or preserves its planarity, when its edges become multiple edges by the addition of edges to edges in the original graph {\Huge Reference this!!!}.: \vspace{-0.1cm}
			\begin{itemize} \itemsep -1pt
			\item Does the following reference suffice {\bf for all conditions}? \url{http://jgaa.info/accepted/2004/BoyerMyrvold2004.8.3.pdf}.
			\end{itemize}
		\item Representations for different types of {\bf multigraphs} \cite{WikipediaContributors2018a39}: \vspace{-0.1cm}
			\begin{itemize} \itemsep -1pt
			\item A {\bf multidigraph} is also known as {\bf quiver} \cite{WikipediaContributors2018a40}.
			\item {\bf undirected multigraph, which edges have no identity}, is an ordered pair (or 2-tuple) $G = (V, E)$, where $V$ is a set of vertices (or, nodes), $E$ is a multi-set of undirected edges (or unordered pairs of vertices).
			\item {\bf undirected multigraph, which edges have an identity each (or, where each edge has an identity)}, is an ordered triple (or 3-tuple) $G = (V, E, r)$, such that $r: E \rightarrow \{\{x, y\} : x, y \in V\}$ is a function that assigns each edge to an unordered pair of vertices (i.e., endpoint nodes).
			\item {\bf directed multigraph (or multidigraph or quiver), which edges have no identity}, is an ordered pair (or 2-tuple) $G = (V,E)$. Here, $V$ is a set of vertices (or, nodes), and $E$ is a multi-set of ordered pairs of vertices (i.e., directed edges, directed arcs, or arrows)
			\item A {\bf mixed multigraph} is a(n) (ordered) 3-tuple $G = (V, E, A)$, where $V$ is a set of vertices (or, nodes), $E$ is a set of undirected edges, and $A$ is a multi-set of directed edges/arcs.
			\item A {\bf directed multigraph (or multidigraph or quiver), which edges have an identity each (or, where each edge has an identity)}, is a 4-tuple $G = (V, E, s, t)$. Here, $V$ is a set of vertices (or nodes), $E$ is a multi-set of ordered pairs of vertices (i.e., directed edges, directed arcs, or arrows), $s : E \rightarrow V$ so that each edge is assigned to its source node, and $t : E \rightarrow V$ so that each edge is assigned to its destination/target node.
			\end{itemize}
		\item A {\bf labeled multigraph} is a 6-tuple $G = (\sum_{V}, \sum_{E}, V, E, l_{V}, l_{E})$. Here, $V$ is a set of vertices (or, nodes), and $E$ is a multi-set of ordered pairs of vertices (i.e., directed edges, directed arcs, or arrows), $\sum_{V}$ is the finite alphabet of available vertex labels, $\sum_{E}$ is the finite alphabet of available edge labels, $l_{V} : V \rightarrow \sum_{V}$ is a map describing the labeling of the vertices, and $l_{E} : E \rightarrow \sum_{E}$ is a map describing the labeling of the edges.
		\item A {\bf labeled multidigraph} is also known as a {\bf labeled, directed multigraph}. It is a 8-tuple $G = (\sum_{V}, \sum_{E}, V, E, s, t, l_{V}, l_{E})$. Here, $V$ is a set of vertices (or, nodes), and $E$ is a multi-set of ordered pairs of vertices (i.e., directed edges, directed arcs, or arrows), $\sum_{V}$ is the finite alphabet of available vertex labels, $\sum_{E}$ is the finite alphabet of available edge labels, $s : E \rightarrow V$ so that each edge is assigned to its source node (or, is a map that assigns each edge to its source node), $t : E \rightarrow V$ so that each edge is assigned to its destination/target node (or, is a map that assigns each edge to its destination/target node), $l_{V} : V \rightarrow \sum_{V}$ is a map describing the labeling of the vertices, and $l_{E} : E \rightarrow \sum_{E}$ is a map describing the labeling of the edges.
		\item References: %\vspace{-0.1cm}
			\begin{itemize} %\itemsep -1pt
			\item {\bf Multiple edges}: \url{https://en.wikipedia.org/wiki/Multiple_edges}
			\item {\bf Multigraph} \cite{WikipediaContributors2018a39}: \url{https://en.wikipedia.org/wiki/Multigraph}
			\item {\bf Graph labeling} \cite{WikipediaContributors2017a12}: %\vspace{-0.1cm}
				\begin{itemize} %\itemsep -1pt
				\item \url{https://en.wikipedia.org/wiki/Graph_labeling}
				\item ``{\bf Graph labeling} is the assignment of labels,'' which can be represented by numbers and/or strings, to edges and/or vertices of a graph.
				\item {\bf Vertex labeling} is a function of $V$\ that assigns a set of labels to $V$; or, it is a function of $V$that assigns a label to each vertex.
				\item A {\bf vertex-labeled graph} is a graph with a defined vertex labeling function.
				\item {\bf Edge labeling} is a function of $E$\ that assigns a set of labels to $E$; or, it is a function of $E$that assigns a label to each edge.
				\item An {\bf edge-labeled graph} is a graph with a defined edge labeling function.
				\item A {\bf weighted graph} is an {\bf edge-labeled graph}, such that the edge labels are members of an ordered set (e.g., the set of real numbers $\mathbb{R}$).
				\item The term {\bf labeled graph} generally refers to a {\bf vertex-labeled graphs} with unique labels (e.g., $\{1, \dots, |V|\}$, where $|V|$ is the number of vertices in the graph or the cardinality of $V$), unless otherwise specified.
				\end{itemize}
			\end{itemize}
		\end{enumerate}
	\item {\bf hypergraph}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item Related to spectral graph theory, which involves linear algebra.
		\item References for hypergraphs:
			\begin{itemize}
			\item \cite{Bretto2013}
			\item \cite{Cong2003a}
			\item \cite{Alpert1996}
			\item \cite{Berge1989}
			\item \cite{Johnson2013b}
			\item Not so good references: \cite{Basu2007,Lovasz2012,Bunke2008,Crama2011,Lecoutre2009,Carrington2005,Scheinerman1997,Sarrafzadeh1996}
			\end{itemize}
		\end{enumerate}
	\item {\bf multidimensional networks}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item One of the distinguishing features of multi-dimensional edges is multiple edges.
		\end{enumerate}
	\item {\bf mixed graph}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item 
		\end{enumerate}
	\item {\bf Planar graph} \cite{WikipediaContributors2018a43}: %\vspace{-0.2cm}
		\begin{enumerate} %\itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Planar_graph}
		\item Are all planar graphs sparse graphs? \cite{WikipediaContributors2018a43}
		\item ``A {\bf planar graph} is a graph that can be embedded in the plane'', such that when the graph is visualized in 2-dimensions, its edges only intersect at their endpoints (or, its edges do not intersect each other) \cite{WikipediaContributors2018a43}.
			\begin{itemize}
			\item Such visualizations are known as {\bf planar embeddings of the graph}, or {\bf plane graphs} \cite{WikipediaContributors2018a43}.
			\item A {\bf planar embedding of a planar graph} $G_{P} = (V_{P}, E_{P})$ is a mapping of vertices $v_{i} \in V_{P} = \{v_{1}, \dots, v_{n}\}, \forall i \in \{1, \dots, n\},$ to points on a plane, and a mapping of edges $e_{j} \in E_{P} = \{e_{1}, \dots, e_{m}\}, \forall j \in \{1, \dots, m\},$ to plane curves on that plane, such that no planar curve intersects another planar curve and planar curves are connected at points in that plane \cite{WikipediaContributors2018a43}.
			\end{itemize}
		\end{enumerate}
	\item {\bf dipole graph}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item A {\bf dipole graph} (or {\bf bond graph} -- not that kind of {\bf bond graph}) has a set of only two vertices, and a set of (parallel) edges between these vertices.: \vspace{-0.1cm}
			\begin{itemize} \itemsep -1pt
			\item A {\bf bond graph} is a graphical representation of a physical dynamic system, and represents exchanges of physical energy; see \url{https://en.wikipedia.org/wiki/Bond_graph}.
			\end{itemize}
		\item An {\bf order-$n$ dipole graph} $Dn$ is a dipole graph with $n$ edges, and is a dual to the cycle graph $C_{n}$.
		\item References: \vspace{-0.1cm}
			\begin{itemize} \itemsep -1pt
			\item {\bf Multiple edges}: \url{https://en.wikipedia.org/wiki/Multiple_edges}
			\item {\bf Dipole graph}: \url{https://en.wikipedia.org/wiki/Dipole_graph}
			\end{itemize}
		\end{enumerate}
	\item A {\bf dual graph} $H = \{V_{H}, E_{H}\}$ of a {\bf planar graph} $G = \{V_{G}, E_{G}\}$ \cite{WikipediaContributors2018a43} is a graph that maps each vertex $v_{i} \in V_{G} = \{v_{1}, \dots, v_{n}\}, \forall i \in \{1, \dots, n\}, n \geq 3,$ to each face of $H$, and maps each vertex $v_{j} \in V_{H} = \{v_{1}, \dots, v_{m}\}, \forall j \in \{1, \dots, m\},$ to a face in $G$, and each edge $e_{k} \in E_{H} = \{e_{1}, \dots, e_{o}\}, \forall k \in \{1, \dots, o\},$ connects adjacent faces of $G$ that are separated by an edge. Hence, each edge $e_{l} \in E_{G} = \{e_{1}, \dots, e_{p}\}, \forall l \in \{1, \dots, p\},$ corresponds to a dual edge $e_{k}$ in $H$, such that the endpoints of $e_{k}$ are the dual vertices corresponding to faces on both sides of $e_{l}$ \cite{WikipediaContributors2018a48}.\vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item The definition of $H$ depends on the {\bf planar embedding} of $G$, since the {\bf duality property} is a property of the {\bf planar embedding} (as opposed to planar graphs that can be embedded, but its embedding is not known yet) \cite{WikipediaContributors2018a48}.
		\item Hence, a planar graph can have multiple dual graphs, since it can have multiple {\bf planar embeddings} \cite{WikipediaContributors2018a48}.
		\item ``The property of being a dual graph is symmetric,'' such ``that if $H$ is the dual of a connected graph $G$ [(the {\bf primal graph})], then $G$ is [also] a dual of $H$'' \cite{WikipediaContributors2018a48}.
		\item Graph properties and structures of the {\bf primal graph} $G$ have {\bf dual properties and structures} in the dual graph $H$ \cite{WikipediaContributors2018a48}. Such graph properties and structures include the following \cite{WikipediaContributors2018a48}:
			\begin{itemize}
			\item cycles are dual to cuts
			\item spanning trees are dual to complements of spanning trees
			\item simple graphs are dual to 3-edge-connected graphs
			\end{itemize}
		\item Based on the {\bf Jordan curve theorem}, the {\bf dual of the $n$-cycle graph} (or, {\bf $n$-vertices graph}) is the {\bf $n$-edge dipole graph} \cite{WikipediaContributors2018a48}; see \url{https://en.wikipedia.org/wiki/Jordan_curve_theorem}.
		\item ``A {\bf plane graph} is said to be {\bf self-dual} if it is {\bf isomorphic} to its dual graph'' \cite{WikipediaContributors2018a48}.
		\item Since a {\bf dual graph} $H$ is dependent on the {\bf planar embedding} of the graph $G$, there does not exist any unique {\bf dual graph} for graph $G$. That is, a {\bf planar graph} can have {\bf non-isomorphic dual graphs} \cite{WikipediaContributors2018a48}.
		\end{enumerate}
	\item A {\bf bouquet grap} $B_{m}$ ``is an undirected graph with one vertex and {\bf $m$'' self-loops} \cite{WikipediaContributors2018a47}. That is, each edge in the undirected graph  $B_{m}$ is a {\bf self-loop} \cite{WikipediaContributors2017a13}.
	\end{enumerate}
\item {\bf directed graph}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item {\bf directed multigraphs}: see aforementioned notes on ``{\bf directed multigraph} (or {\bf multidigraph}), which edges have no identity,'' and ``{\bf directed multigraph} (or {\bf multidigraph}), which edges have an identity each (or, where each edge has an identity)''
	\item {\bf directed acyclic graphs} ({\bf DAGs})
	\item See \S\ref{ssec:DirectedGraphsAndDirectedAcyclicGraphs} for notes on directed graphs (digraphs) and DAGs.
	\end{enumerate}
\item {\bf mixed graphs}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item A mixed graph $G = (V, E, A)$ is a mathematical object that is a 3-tuple (or, triple or triplet), where $V$ is the set of vertices in $G$, $E$ is the set of undirected edges in $G$, and $A$ is the set of directed edges in $G$ \cite{WikipediaContributors2018a50}.
	\item \cite{WikipediaContributors2018a50} provides definitions for: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item directed edges
		\item undirected edges
		\item mixed cycle (cycle of a mixed graph)
		\item acyclic mixed graph
		\item graph coloring problem of mixed graphs: \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item (strong) proper k-coloring of a mixed graph
			\item weak proper k-coloring of a mixed graph
			\item chromatic number
			\item chromatic polynomial of graph $G$
			\item weak chromatic polynomial of graph $G$
			\end{enumerate}
		\end{enumerate}
	\item \cite{WikipediaContributors2018a50} describes applications of mixed graph in the following problems/topics: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item Bayesian inference
		\item Scheduling problem
		\end{enumerate}
	\end{enumerate}
\end{enumerate}







Additional resources about graphs: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item {\bf Graph property}, or {\bf graph invariant}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \url{https://en.wikipedia.org/wiki/Graph_property}
	\item Notes about vertices/nodes: \vspace{-0.2cm}
		\begin{enumerate} %\itemsep -1pt
		\item If the graph contains an edge connecting vertices $u$ and $v$, $e = (u, v)$, the vertices $u$ and $v$ are {\bf adjacent} to each other \cite{WikipediaContributors2017a11}.
		\item The {\bf degree (or valency) of vertex} $v$, which is denoted by $\delta(v)$ (or, ${\rm deg}(v)$ or ${\rm deg}\ v$), is the number of edges that are incident to $v$ \cite{WikipediaContributors2017a11,WikipediaContributors2018a37}.: \vspace{-0.1cm}
			\begin{itemize} \itemsep -1pt
			\item Regarding undirected graphs, the degree of a vertex $\deg(v)$ is equal to the number of edges (i.e., $n$) \cite{WikipediaContributors2017a13}; i.e., $\deg(v) = n$.
			\end{itemize}
		\item An {\bf isolated vertex} is a vertex with degree zero, $\delta(v) = 0$. It is not an endpoint of any edge; or, no edge in a (or, any) graph is defined with an isolated vertex \cite{WikipediaContributors2018a37,WikipediaContributors2017a11}.
		\item A {\bf leaf vertex}, {\bf end vertex}, or {\bf pendent vertex}, is a vertex of degree one, $\delta(v) = 1$, and is an endpoint of only one edge ({\bf pendent edge}) in the graph \cite{WikipediaContributors2018a37,WikipediaContributors2017a11}.
		\item A {\bf dominating vertex} is ``a vertex with degree $\delta(v) = (n - 1)$ in a graph of $n$ vertices'' \cite{WikipediaContributors2018a37}.
		\item For a vertex $v$ of a directed graph, the {\bf outdegree} of $v$ (denoted by $\delta^{+}(v)$) is its number of outgoing edges, and the {\bf indegree} of $v$ (denoted by $\delta^{-}(v)$) is its number of incoming edges. A {\bf source vertex} is a vertex with a zero indegree ($\delta^{-}(v) = 0$), and a {\bf sink vertex} is a vertex with a zero outdegree ($\delta^{+}(v) = 0$) \cite{WikipediaContributors2017a11}.
		\item A vertex $v$, which has no {\bf incident edges} apart from a(n) (undirected) loop from $v$ to itself, has a degree of two; i.e., ${\rm deg}(v) = 2$ \cite{WikipediaContributors2018a37}. \vspace{-0.1cm}
			\begin{itemize} \itemsep -1pt
			\item ``A {\bf loop}, {\bf self-loop} \cite[\S B.4, pp. 1168]{Cormen2009}, or {\bf buckle}, is an edge that connects a vertex to itself'' \cite{WikipediaContributors2017a13}.
			\item Regarding {\bf undirected graphs}, the {\bf degree of a vertex} with a loop and no other {\bf incident edges} is two; i.e., $\deg(v) = 2$ \cite{WikipediaContributors2017a13}.
			\item Regarding undirected graphs, a vertex with a loop and no other incident edges has an indegree of one $\delta^{-}(v) = 1$ and an outdegree of one $\delta^{+}(v) = 1$ \cite{WikipediaContributors2017a13}.
			\end{itemize}
		\item For a graph $G$, its {\bf maximum degree} $\Delta(G)$ and its {\bf minimum degree} $\delta(G)$ are the maximum and minimum degree of its vertices \cite{WikipediaContributors2018a37}.
		\item A {\bf cut vertex} is a vertex that would disconnect the graph when it is removed \cite{WikipediaContributors2017a11}.
		\item A {\bf vertex cut} $S$ (or, {\bf vertex separator}, or {\bf separating set}) is a {\bf vertex subset} ($S \subset V$) for non-adjacent vertices (or subgraphs \cite{WikipediaContributors2018a44}) $a$ and $b$, if the removal of the {\bf vertex cut} $S$  disconnects/separates the subgraphs ``$a$ and $b$ into distinct connected components'' \cite{WikipediaContributors2016n}.
		\end{enumerate}
	\item Notes about {\bf edges}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item {\bf Edges for directed graphs} are also called {\bf arcs} \cite{WikipediaContributors2018a44}.
			\begin{itemize}
			\item Alternate names for {\bf edges of directed graphs} include {\bf ordered pairs of vertices}, {\bf arrows}, {\bf directed edges}, {\bf directed arcs}, and {\bf directed lines}; see \url{https://en.wikipedia.org/wiki/Directed_graph}.
			\item A {\bf directed edge} has a {\bf head} and a {\bf tail}; see \url{https://en.wikipedia.org/wiki/Directed_graph}. {\it What about {\bf directed hyperedges} of {\bf directed hypergraphs}???}
			\end{itemize}
		\item Alternate names for {\bf edges of undirected graphs} include {\bf unordered pairs of vertices}, and {\bf lines}; see \url{https://en.wikipedia.org/wiki/Directed_graph}.
		\item An {\bf endpoint} is a vertex connected by an edge \cite{WikipediaContributors2018a44}. 
		\item An {\bf edge} has at least one endpoint (i.e., loop/self-loop). {\bf Hyperedges} of {\bf hypergraphs} can connect to more than 2 vertices; i.e., {\bf hyperedges} can have more than 2 endpoints \cite{WikipediaContributors2018a44}.
		\item A {\bf half-edge} is an edge with only one end, or {\bf loose edge} has no ends \cite{WikipediaContributors2018a38}.
		\item The {\bf directed edge} $e = (u, v)$ \cite[\S B.4, pp. 1169]{Cormen2009} (of a directed graph) is {\bf incident from}, or {\bf leaves}, vertex $u$, and is {\bf incident to}, or {\bf enters}, vertex $v$.
		\item The {\bf undirected edge} $e = (u, v)$ \cite[\S B.4, pp. 1169]{Cormen2009} (of an undirected graph) is {\bf incident on} vertices $u$ and $v$.
		\item {\bf Adjacent vertices} are connected to each other by an edge \cite[\S B.4, pp. 1169]{Cormen2009}. For undirected graphs, this ``{\bf adjacency relation} is symmetric'' \cite[\S B.4, pp. 1169]{Cormen2009}. Regarding directed graphs, this ``{\bf adjacency relation} is not necessarily symmetric'' \cite[\S B.4, pp. 1169]{Cormen2009}, since $(u, v)$ may exist (hence, implying an adjacency relation) but $(v, u)$ is nonexistent.
		\item References:
			\begin{itemize}
			\item \cite{WikipediaContributors2018a44}
			\end{itemize}
		\end{enumerate}
	\item An {\bf independent set} is a set of vertices $S$ such that no pair vertices $(v_{i}, v_{j}), \forall i \forall j \in V, V = \{v_{1}, \dots, v_{n}\}$ has an edge connecting them \cite{WikipediaContributors2017a11,WikipediaContributors2018a45}. %\vspace{-0.2cm}
		\begin{enumerate} %\itemsep -2pt
		\item That is, there does not exist any edge $\not\exists e = (v_{i}, v_{j}), \forall i \forall j \in V, V = \{v_{1}, \dots, v_{n}\}$.
		\end{enumerate}
	\item The {\bf handshaking lemma} \cite{WikipediaContributors2018a46,WikipediaContributors2018a37} states that the number of vertices with odd degree in any undirected graph $G = (V, E)$ is even. $\displaystyle\sum_{v \in V} \deg(v) = 2|E|$.
	\end{enumerate}
\item A {\bf subgraph} $S = (V_{S}, E_{S})$ of a graph $G = (V_{G}, E_{G})$ is another graph that includes a subset of the vertices and edges of $G$, such that $S \neq G, S \not\subset G, V_{S} \subset V_{G}, E_{S} \subset E_{G}$, and $(S \cap G) = S$ \cite{WikipediaContributors2018a44}.
\item {\bf Multi-dimensional networks}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item {\bf Multi-dimensional networks} belong to type of {\bf multi-layer networks} that have multiple types/kinds of relations \cite{WikipediaContributors2018a42}.
	\item A {\bf multi-dimensional network} can be modeled with a {\bf multipartite edge-labeled multigraph} \cite{WikipediaContributors2018a41,WikipediaContributors2018a42}.
	\item An {\bf unweighted multi-layer network} can be represented as a triple $G = (V, E, D)$, where (or, in which) $V$ is a set of vertices, $E$ is a dimension-specific set of edges connecting the vertices and each edge is represented by the triple $(u, v, d)$ such that $u, v, \in V$ and $d \in D$ (or, $E = \{(u, v, d); u, v \in V, d \in D$), and $D$ is a set of dimensions or layers \cite{WikipediaContributors2018a42}. %\vspace{-0.2cm}
		\begin{enumerate} %\itemsep -2pt
		\item For an {\bf unweighted, undirected multi-layer network}, the edges/links $(u, v, d)$ and $(v, u, d)$ are equivalent.
		\item For an {\bf unweighted, directed multi-layer network}, the edges/links $(u, v, d)$ and $(v, u, d)$ are different/distinct.
		\item By convention, {\bf unweighted multi-layer network} are not {\bf multigraphs} in a given dimension; hence, ``the number of $[$edges/$]$links between two nodes in a given dimension is either zero or one''. ``However, the total number of $[$edges/$]$links between two nodes across all dimensions is less than or equal to $| D |$.''
		\end{enumerate}
	\item An edge of a {\bf weighted multi-layer network} can be represented as a 4-tuple (or, quadruplet) $e = (u, v, d, w)$, ``where $w$ is the weight of the $[$edge/$]$link between $[$vertex$]$ $u$ and $[$vertex$]$ $v$ in the dimension $d$'' \cite{WikipediaContributors2018a42} %\vspace{-0.2cm}
		\begin{enumerate} %\itemsep -2pt
		\item {\bf Weighted multi-layer networks}, like {\bf unweighted multi-layer networks}, can also be represented as a triple $G = (V, E, D)$, where $V$ is the set of vertices, $E$ is the set of edges (each edge is represented by $e = (u, v, d, w)$), or $E = \{(u, v, d, w); u, v \in V, d \in D, w \in W\}$, $W$ is a set of weights, and $D$ is a set of dimensions or layers.
		\item A {\bf weighted multi-layer networks}, where an edge is defined as $e = (u, v, d_{1}, \dots, d_{n}, w)$, such that $d_{1}, \dots, d_{n} \in D$, can model {\bf multidimensional temporal networks}, or {\bf multidimensional time-varying networks} \cite{WikipediaContributors2018a42}.
		\end{enumerate}
	\item {\bf Multidimensional network} \cite{WikipediaContributors2018a42}: \url{https://en.wikipedia.org/wiki/Multidimensional_network}.
	\item {\bf Multipartite graph} \cite{WikipediaContributors2018a41}: \url{https://en.wikipedia.org/wiki/Multipartite_graph}
	\item {\bf Temporal network}, or {\bf time-varying network}: \url{https://en.wikipedia.org/wiki/Temporal_network}
	\item A {\bf 1-dimensional (1-D) network} has a {\bf 2-dimensional (2-D) adjacency matrix} with the size $V \times V$; $A^{i}_{j}$ is an adjacency matrix that encodes edges/links/connections between vertices $i$ and $j$.
	\item For a {\bf multi-dimensional network} with $| D |$ dimensions, it has a {\bf multi-layer adjacency tensor (or, 4-dimensional matrix, or 4-D matrix)} with the size $(V \times D) \times (V \times D)$; $M^{i\alpha}_{j\beta}$ is an {\bf multi-layer adjacency tensor} that encodes edges/links/connections between vertices $i$ in layer $\alpha$ and $j$ in layer $\beta$ \cite{WikipediaContributors2018a42}.
	\end{enumerate}
\item {\bf infinite graph}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item An {\bf infinite graph} is a graph that is not finite. This can be worded better.
	\end{enumerate}
\item {\bf extremal graphs}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item ``{\bf Extremal graph theory} studies {\bf extremal (maximal or minimal) graphs} which satisfy a certain property. Extremality can be taken with respect to different graph invariants, such as order, size or girth.''
	\item \url{https://en.wikipedia.org/wiki/Extremal_graph_theory}
	\end{enumerate}
\item {\bf random graphs}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \url{https://en.wikipedia.org/wiki/Random_graph}
	\item Wrongly referred to as probabilistic graph theory in \url{https://en.wikipedia.org/wiki/Graph_theory}
	\end{enumerate}
\item {\bf Topological graph theory}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \url{https://en.wikipedia.org/wiki/Topological_graph_theory}
	\end{enumerate}
\item {\bf Geometric graph theory}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \url{https://en.wikipedia.org/wiki/Geometric_graph_theory}
	\end{enumerate}
\end{enumerate}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Graph Representations}
\label{ssec:GraphRepresentations}

Focus on {\bf sparse graph representations}, which are common in modeling digital integrated circuits and neural networks (certain types), and {\bf dense graphs} (e.g., neural networks). \\

For {\bf sparse graphs}, use {\bf adjacency list} (or {\bf adjacency map} \cite{Goodrich2013}) -based graph representations for {\bf better memory efficiency} \cite{WikipediaContributors2018a49}. \\




For {\bf dense graphs} (i.e., $| E | \approx | V |^{2}$), use {\bf adjacency matrix-based graph representation} for {\bf faster access time} for finding edges at the expense of {\bf worse memory efficiency} \cite{WikipediaContributors2018a49}; see \url{https://en.wikipedia.org/wiki/Dense_graph}. Also, see \url{https://en.wikipedia.org/wiki/Dense_subgraph} regarding dense subgraphs. \\

Hence, there exists a {\bf trade-off between access time and member efficiency in graph representations}.\\

The ways to represent graphs are listed as follows: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item {\bf adjacency matrix}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item 
	\item References: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \cite{WikipediaContributors2018a49,Savage1998}
		\item \cite[\S52.7, pp. 844; \S52.6--\S52.7, pp. 851--856]{Goldman2008}
		\item Memory/Space efficient representation of dense graphs, especially when they are not multigraphs. It can represent dense undirected graphs most efficiently \cite[\S54, pp. 883]{Goldman2008}.
		\item For enumerating the edges outgoing from or incoming to a vertex in the graph, it takes $O(n)$ time, which slows down algorithms that need to enumerate edges outgoing from or incoming to each vertex in the graph \cite[\S54, pp. 883]{Goldman2008}.
		\item An adjacency matrix is a preferred representation for dense graphs, which have the property $|E| \approx |V|^{2}$. It is also preferred if there exists a need to frequently determine if there is an edge connecting any given pair of vertices (fast lookup, or fast access time) \cite[\S22.1, pp. 589]{Cormen2009}. The reference \cite[\S22.1, pp. 589--590]{Cormen2009} covers {\bf adjacency matrix} graph representation.
		\item \cite[\S5, pp. 78]{Cormen2013}
		\item Its computational space complexity is $O(|V|^{2})$ \cite[\S13.2, pp. 600]{Goodrich2011} \cite[\S14.2, pp. 627]{Goodrich2013} \cite{WikipediaContributors2018a49}.
		\item \cite[\S13.2.3, pp. 605--606]{Goodrich2011}
		\cite[\S14.2, pp. 627; \S14.2.4, pp. 633]{Goodrich2013}
		\end{enumerate}
	\end{enumerate}
\item {\bf adjacency list}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite[\S52.7, pp. 850-854]{Goldman2008}
	\item References: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \cite{WikipediaContributors2018a49}
		\item \cite[\S52.7, pp. 854; \S52.6--\S52.7, pp. 851--856; \S55, pp. 901--915]{Goldman2008}
		\item An adjacency list is a compact representation for sparse graphs \cite[\S54, pp. 883]{Goldman2008}, which have the property $|E| \ll |V|^{2}$ \cite[\S22.1, pp. 589]{Cormen2009}. \cite[\S22.1, pp. 589,591--592]{Cormen2009} covers {\bf adjacency matrix} graph representation. That is, it is ``space efficient'' \cite[\S55, pp. 901]{Goldman2008}, or memory efficient.
		\item It enables algorithms to efficiently (in regards to computational time complexity) enumerate edges outgoing from or incoming to each vertex in the graph faster than the adjacency matrix graph representation \cite[\S55, pp. 901]{Goldman2008}; the vertices in the graph are enumerated in a data-dependent order. The computational time complexity of enumerating the list of incoming edges and the list of outgoing edges can be reduced by using a set of incoming edges and a set of outgoing edges, due to the hashing properties of hash sets.
		\item \cite[\S5, pp. 79]{Cormen2013}
		\item Its computational space complexity is $O(|V|+|E|)$ \cite[\S13.2, pp. 600]{Goodrich2011} \cite[\S14.2, pp. 627]{Goodrich2013} \cite{WikipediaContributors2018a49}. While it is space efficient for sparse graphs, it is not space efficient for dense graphs.
		\item \cite[\S55.1, pp. 904]{Goldman2008} mentions using a bucket mapping \cite[\S55.1, pp. 904; \S50.3, pp. 829; \S2.6.2, pp. 27; \S50; \S29.5, pp. 447]{Goldman2008} to implement the augmented adjacency sets that is used to store a set of incoming edges and a set of outgoing edges. The bucket mapping \cite[\S55.1, pp. 904; \S50.3, pp. 829]{Goldman2008}, or tagged bucket collection type \cite[\S2.6, pp. 25]{Goldman2008}, is based on a hash table. Bucket mapping, just like sets and mappings, are based on hash tables \cite[\S1.5, pp. 9]{Goldman2008}.
		\item \cite[\S13.2.2, pp. 603--604]{Goodrich2011}
		\item \cite[\S14.2, pp. 627; \S14.2.2, pp. 630--631]{Goodrich2013}
		\end{enumerate}
	\end{enumerate}
\item {\bf adjacency map}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item Its computational space complexity is $O(|V|+|E|)$ \cite[\S14.2, pp. 627]{Goodrich2013}.
	\item \cite[\S14.2, pp. 627; \S14.2.3, pp. 632; \S14.2.5, pp. 634--637]{Goodrich2013}
	\end{enumerate}
\item {\bf edge list}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item Is this equivalent to the ``{\bf incidence list}'' graph representation? {\Huge Cite this!!!}
	\item \cite[\S5, pp. 78]{Cormen2013} describes the use of an unordered list to store the set of edges in the graph.
	\item Its computational space complexity is $O(|V|+|E|)$ \cite[\S13.2, pp. 600]{Goodrich2011} \cite[\S14.2, pp. 627]{Goodrich2013}.
	\item \cite[\S13.2.1, pp. 600--602]{Goodrich2011}
	\item \cite[\S14.2, pp. 627; \S14.2.1, pp. 628--629]{Goodrich2013}
	\end{enumerate}
\item {\bf incidence matrix}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item Its computational space complexity is $O(|V| \cdot |E|)$ \cite{WikipediaContributors2018a49}.
	\item References: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \cite{WikipediaContributors2018a49}
		\end{enumerate}
	\end{enumerate}
\end{enumerate}


Alternate graph representations that I am not exploring: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item {\bf distance matrix}: \url{https://en.wikipedia.org/wiki/Distance_matrix}
\end{enumerate}

From \cite{WikipediaContributors2018a49}, the adjacency list graph representation is more efficient in terms of computational space complexity than the adjacency matrix and incidence matrix graph representations.



References to cover: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item \cite[\S4-\S10, \S19, \S21-24, \S25-\S29]{Atallah2009}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item See \cite[\S3]{Atallah2009} regarding external sorting.
	\item There exist a trade-off between computational time and space complexities in most data structures \cite[\S4.1.3, pp. 4-2]{Atallah2009}, including graphs.
	\item Use a ``rooted tree with path compression'' for ``a simple and optimal'' implementation of the union-find data structure \cite[\S4.1.4, pp. 4-3]{Atallah2009}.
	\item See \cite[\S7-\S9]{Atallah2009} regarding graph algorithms.
	\item See \cite[\S10]{Atallah2009} regarding external-memory algorithms and data structures. 
	\item See \cite[\S11]{Atallah2009} regarding average case analysis of algorithms, using probabilistic models and (probabilistic) techniques.
	\item See \cite[\S12]{Atallah2009} regarding randomized algorithms.
	\item See \cite[\S24]{Atallah2009} regarding complexity classes and measures for quantum computing.
	\item See \cite[\S25]{Atallah2009} regarding parameterized algorithms.
	\item See \cite[\S26]{Atallah2009} regarding machine learning.
	\item See \cite[\S29]{Atallah2009} regarding distributed computing.
	\end{enumerate}
\item See \cite{Atallah2009a}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item See \cite[\S25]{Atallah2009a} regarding parallel algorithms.
	\item See \cite[\S24]{Atallah2009a} regarding ``Algorithmic Techniques for Regular Networks of Processors''.
	\item See \cite[\S26]{Atallah2009a} regarding self-stabilizing algorithms.
	\item See \cite[\S28]{Atallah2009a} regarding algorithms for implementing computing network protocols.
	\end{enumerate}
\item \cite{Goldman2008}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item Information regarding graph data structures and algorithms are found in \cite[\S51-\S57]{Goldman2008}.
	\item See \cite[\S B.4]{Goldman2008} for information regarding expected time complexity. \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item Use {\bf expected time complexity} for {\it randomized algorithms}, or for {\it measuring computational time complexity based on random input}. For the latter case, we should specify the probability distribution for the possible inputs (e.g., uniform probability distribution). 
		\end{enumerate}
	\item \cite[\S53.8]{Goldman2008} discusses the computational time complexity of the graph algorithms.
	\end{enumerate}
\item \cite{Cormen2009}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite[\S B.4]{Cormen2009} covers graphs, and \cite[\S B.5]{Cormen2009} covers trees.
	\item \cite[\S22.1]{Cormen2009} covers graph representations
	\item \cite[\S D]{Cormen2009} covers basic matrix theory and matrix algebra.
	\item \cite[\S21]{Cormen2009} and \cite[\S14.7]{Goodrich2013} cover data structures for disjoint sets.
	\item \cite[\S52, pp. 843--844; \S52.2, pp. 845--848]{Goldman2008} covers information on graph theory. {\bf Update references in graph theory with this section!!!}
	\end{enumerate}
\item \cite{Cormen2013}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite[\S13.1]{Cormen2013} covers information on graph theory. {\bf Update references in graph theory with this section!!!}
	\item 
	\end{enumerate}
\item \cite{Goodrich2011}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite[\S13.1]{Goodrich2011} covers information on graph theory. {\bf Update references in graph theory with this section!!!}
	\end{enumerate}
\item \cite{Goodrich2013}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite[\S14.1]{Goodrich2013} covers information on graph theory. {\bf Update references in graph theory with this section!!!}
	\item \cite[\S14.7.3]{Goodrich2013} covers union-find data structures.
	\end{enumerate}
\end{enumerate}

Due to the lengthy coverage of graphs in \cite[\S52-\S57]{Goldman2008}, I would read the following references \cite{Cormen2009,Cormen2013,Goodrich2011} first. Lastly, I would read \cite{Goodrich2013} to implement the adjacency map representation of graphs.


















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Functions that need to be implemented}
\label{ssec:FunctionsThatNeedToBeImplemented}


%	\cite[\S14.1.1, pp. 626]{Goodrich2013}
My ontology of graphs is based on whether they are directed, undirected, or mixed graphs \cite{WikipediaContributors2018a50}.

Other ontologies of graphs are based on whether the graphs are: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item weighted \cite{WikipediaContributors2018a38,Goldman2008}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item weighted graphs \cite[\S52, pp. 843; \S51, pp. 842]{Goldman2008}
	\item unweighted graphs \cite[\S52, pp. 843; \S51, pp. 842]{Goldman2008}
	\end{enumerate}
\item density/sparsity of the edges in a graph: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item Criteria for a graph to be considered as a dense graph: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item $m \geq \frac{n^{2}}{4}$, or comparable arbitrarily chosen cutoff \cite[\S52.2, pp. 848; \S55, pp. 901]{Goldman2008}.
		\end{enumerate}
	\item Criteria for a graph to be considered as a sparse graph: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item  \cite[\S52.2, pp. 848]{Goldman2008}.
		\end{enumerate}
	\end{enumerate}
\end{enumerate}

Required, or strongly preferred, data structures for implementing graphs: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item Fibonacci heap: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item Used to implement the following graph algorithms: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item Dijkstra's single-source shortest path algorithm \cite[\S24.8, pp. 351; \S57, pp. 925]{Goldman2008}.
		\item all-pairs shortest paths algorithm \cite[\S24.8, pp. 351]{Goldman2008}.
		\item Prim's or Prim-Jarnik algorithm minimum spanning tree problem \cite[\S24.8, pp. 351; \S57, pp. 925]{Goldman2008}.
		\end{enumerate}
	\item ``The Fibonacci heap is a forest, and not a tree'' \cite[\S28.2, pp. 426]{Goldman2008}..
	\item When implementing priority queues, it uses constant time for merge operation instead of logarithmic time (leftist heap) or linear time (binary heap) \cite[\S24.4, pp. 346]{Goldman2008}.
	\item It has poor computational space complexity \cite[\S24.4, pp. 346--347]{Goldman2008}.
	\item See \cite[\S24.7, pp. 350]{Goldman2008} for the class hierarchy of priority queues and their implementations using binary heaps, leftist heaps, or pairing heaps (including Fibonacci heaps).
	\item Instead of using the Fibonacci heap, use pairing heap to implement Prim's algorithm, or Prim-Jarnik algorithm, for minimum spanning trees \cite[\S24.8, pp. 351]{Goldman2008}. 
	\end{enumerate}
\item circular array for topological sort (for DAGs) \cite[\S53, pp. 857]{Goldman2008}.
\item queue (FIFO) for BFS \cite[\S53, pp. 857]{Goldman2008}.
\item open addressing for strongly connected components (for directed graphs) \cite[\S53, pp. 857]{Goldman2008}.
\item open addressing mapping for DFS \cite[\S53, pp. 857]{Goldman2008}.
\end{enumerate}

 


Common functions that need to be implemented in graph data structures; they are instance methods, unless indicated otherwise (as static methods):
\begin{enumerate}
\item {\bf Graph class}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item Standard constructor: {\it Graph(list\_of\_graph\_vertices)}. %\cite[\S52.4, pp. 849; \S52.5, pp. 850]{Goldman2008}.
	\item Standard constructor: {\it Graph(list\_of\_graph\_vertices, list\_of\_graph\_edges)} \cite[\S52.4, pp. 849; \S52.5, pp. 850]{Goldman2008}.
	\item {\tt is\_adjacent($v_{u}, v_{v}$)}: $v_{u}$ and $v_{v}$ are vertices (of the graph), if $v_{u}, v_{v} \in V_{G}$ \cite{WikipediaContributors2018a49} \cite[\S13.1.1, pp. 599]{Goodrich2011}.
	\item {\tt get\_neighbors($v_{u}$)}: $v_{u}$ is a vertex (of the graph), if $v_{u} \in V_{G}$ \cite{WikipediaContributors2018a49} (for hypergraphs). Or, name it {\tt opposite\_vertex($v_{u}$)} \cite[\S13.1.1, pp. 599]{Goodrich2011}, or {\tt get\_neighbor($v_{u}$)} for graphs without hyperedges.
	\item {\tt add\_vertex($v_{u}$)}: $v_{u}$ is a vertex (of the graph), and is added if $v_{u} \not\in V_{G}$ \cite{WikipediaContributors2018a49} \cite[\S13.1.1, pp. 599]{Goodrich2011} \cite[\S52.4, pp. 849; \S52.5, pp. 850]{Goldman2008}.
	\item {\tt remove\_vertex($v_{u}$)}: $v_{u}$ is a vertex (of the graph), and is removed if $v_{u} \in V_{G}$  \cite{WikipediaContributors2018a49} \cite[\S13.1.1, pp. 599]{Goodrich2011} \cite[\S52.4, pp. 849]{Goldman2008}.
	\item {\tt has\_vertex($v_{u}$)} returns boolean {\tt True} if $v_{u} \in V_{G}$. Else, return boolean {\tt False} \cite[\S52.4, pp. 849; \S52.5, pp. 850]{Goldman2008}.
	\item {\tt add\_edge($v_{u}, v_{v}, elem$)}, or {\tt add\_edge($e_{i}, elem$)} \cite[\S52.4, pp. 849; \S52.5, pp. 850]{Goldman2008}: $v_{u}$ and $v_{v}$ are vertices (of the graph), and the edge is added if $v_{u}, v_{v} \in V_{G}$ and edge $e_{i} = (v_{u}, v_{v}) \not\in E_{G}$ \cite{WikipediaContributors2018a49}. $elem$ represents the attribute(s) of the edge object \cite[\S13.1.1, pp. 599]{Goodrich2011}.
	\item {\tt remove\_edge($v_{u}, v_{v}$)}, or {\tt remove\_edge($e_{i}$)}: $v_{u}$ and $v_{v}$ are vertices (of the graph), and the edge is removed if $v_{u}, v_{v} \in V_{G}$ and edge $e_{i} = (v_{u}, v_{v}) \in E_{G}$ \cite{WikipediaContributors2018a49} \cite[\S13.1.1, pp. 599]{Goodrich2011} \cite[\S52.4, pp. 849]{Goldman2008}.
	\item {\tt has\_edge($v_{u}, v_{v}$)}, or {\tt has\_edge($e_{i}$)}: $v_{u}$ and $v_{v}$ are vertices (of the graph), and the boolean {\tt True} is returned if $v_{u}, v_{v} \in V_{G}$ and edge $e_{i} = (v_{u}, v_{v}) \in E_{G}$. Else, return boolean {\tt False} \cite[\S52.4, pp. 849; \S52.5, pp. 850]{Goldman2008}.
	\item {\tt get\_vertex\_attribute\_x($v_{u}$)}: return the value associated with vertex $v_{u}$'s attribute $x$ \cite{WikipediaContributors2018a49}.
	\item {\tt set\_vertex\_attribute\_x($v_{u}, value$)}: assigns/sets the value $value$ associated with vertex $v_{u}$'s attribute $x$ \cite{WikipediaContributors2018a49}.
	\item {\tt get\_edge\_attribute\_x($(v_{u}, v_{v})$)}, or {\tt get\_edge\_attribute\_x($e_{i}$)}: return the value associated with the edge $e_{i} = (v_{u}, v_{v})$'s attribute $x$ \cite{WikipediaContributors2018a49}.
	\item {\tt set\_edge\_attribute\_x($(v_{u}, v_{v}), value$)}, or {\tt set\_edge\_attribute\_x($e_{i}, value$)}: assigns/sets the value $value$ associated with the edge $e_{i} = (v_{u}, v_{v})$'s attribute $x$ \cite{WikipediaContributors2018a49}.
	\item {\tt get\_all\_vertices()} \cite[\S13.1.1, pp. 599]{Goodrich2011}
	\item {\tt get\_all\_edges()} \cite[\S13.1.1, pp. 599]{Goodrich2011}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item For directed graphs, provide a set/list of directed edges. Use the access functions for the head or tail to perform operations on the graph.
		\end{enumerate}
	\item {\tt get\_edge($v_{u}, v_{v}$)} returns the edge $e_{i} = (v_{u}, v_{v}) \in E_{G}$ \cite[\S52.4, pp. 849; \S52.5, pp. 851]{Goldman2008}. Else, return null.
	\item {\tt get\_num\_vertices()} returns the number of vertices in the graph $G = (V_{G}, E_{G})$, or the cardinality of the set/list of vertices $| V_{G} |$ \cite[\S52.4, pp. 849; \S52.5, pp. 851]{Goldman2008}.
	\item {\tt depth\_first\_search(string type)} returns a DFS ordering, which is one of the following DFS-based vertex orderings (preordering, postordering, or reverse postordering) \cite{WikipediaContributors2018a51}. {\it Implementation is found specifically for the abstract directed and undirected graph interfaces/headers/classes.}
	\item {\tt breadth\_first\_search(string type)} returns a BFS ordering \cite{WikipediaContributors2019}. {\it Implementation is found specifically for the abstract directed and undirected graph interfaces/headers/classes.}
	\item {\tt is\_updated()} returns boolean {\tt True} if the graph has been updated since a graph enumeration algorithm has been executed \cite[\S53.1, pp. 858]{Goldman2008}.
	\item {\tt set\_updated()} returns boolean {\tt True} if the graph has been updated since a graph enumeration algorithm has been executed \cite[\S53.1, pp. 858]{Goldman2008}. 
	\item Optional methods: \vspace{-0.2cm}
		\begin{enumerate} %\itemsep -2pt
		\item {\tt boolean is\_multigraph()} returns boolean {\tt True} if the graph is a multigraph. Else, returns boolean {\tt False} \cite[\S52.4, pp. 849]{Goldman2008}.
		\item {\tt boolean set\_as\_multigraph(boolean mgraph)}, where the boolean flag {\tt mgraph} indicates if the graph is a multigraph; if {\tt mgraph} is true, the graph is a multigraph; else, the graph is not a multigraph.
		\item {\tt has\_cycles()} returns boolean {\tt True} if the graph $G$ has cycles; else, it returns boolean {\tt False} \cite[\S52.4, pp. 850]{Goldman2008}.
		\item {\tt is\_cycle($E_{cycle}$)} returns boolean {\tt True} if graph $G$ contains the cycle $E_{cycle}$; else, it returns boolean {\tt False} \cite[\S52.4, pp. 850]{Goldman2008}.
		\item {\tt get\_cycle()} \cite[\S52.4, pp. 850]{Goldman2008}: Not considered, since a graph can have multiple cycles.
		\item While directed and undirected graphs can implement these methods, their implementations are significantly different, and cannot be abstracted from both of these categories of graphs.
		\end{enumerate}
	\item Variables: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item boolean {\tt is\_multigraph} to indicate if the graph is a multigraph \cite[\S53, pp. 857]{Goldman2008}.
		\item set\_of\_cycles
		\item boolean {\tt has\_been\_modified} to indicate if the graph has been modified since a graph enumeration algorithm has been executed; boolean {\tt true} indicates if it has been modified \cite[\S53.1, pp. 858]{Goldman2008}.
		\item Ignore these variables: \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item DFS vertex ordering \cite[\S53, pp. 857]{Goldman2008}, since there exists different types of DFS-based vertex ordering (preordering, postordering, or reverse postordering) \cite{WikipediaContributors2018a51}
			\end{enumerate}
		\end{enumerate}
	\end{enumerate}
\item {\bf Vertex class}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item Accessor and mutator methods for properties of vertices $v_{i}, \forall i \in V_{G} = \{v_{1}, \dots, v_{m}\}$
	\item 
	\end{enumerate}
\item {\bf Edge class}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item Accessor and mutator methods for properties of edges $e_{j}, \forall j \in E_{G} = \{e_{1}, \dots, e_{n}\}$
	\item 
	\end{enumerate}
\end{enumerate}


Common functions that need to be implemented in {\bf undirected graph} data structures; they are instance methods, unless indicated otherwise (as static methods):
\begin{enumerate}
\item {\bf Graph class}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item {\tt is\_path($e_{set}$)}, where $e_{set}$ is a set of edges (or 2-tuples of vertices), and check if this ordered list/set of edges follows a sequence.
	\item {\tt are\_adjacent\_edges($e_{i}, e_{j}$)} \cite[\S13.1.1, pp. 599]{Goodrich2011}
	\item {\tt get\_connected\_components()} returns a set of connected components, where each connected component is defined by a set of vertices \cite[\S52.44, pp. 850]{Goldman2008}.
	\item {\tt add\_connected\_components()} adds a connected component (defined by a set of vertices) to the set of connected components stored by the graph. %\cite[\S52.4, pp. 850]{Goldman2008}.
	\item {\tt get\_number\_of\_connected\_components()} returns the number of connected components in the graph $G$ \cite[\S52.4, pp. 850]{Goldman2008}.
	\item {\tt get\_shortest\_path\_between\_vertices($v_{u}, v_{v}$)} returns the shortest path between vertex $v_{u}$ and vertex $v_{v}$ \cite[\S52.4, pp. 850]{Goldman2008}.
	\item {\tt get\_set\_of\_shortest\_paths\_from\_vertex($v_{u}$)} returns the set of shortest paths between vertex $v_{u}$ to each reachable vertex $v_{i}$ (from $v_{u}$), such that a path from $v_{u}$ to $v_{i}$ exists, $\forall i \in$ set of paths from $v_{u}$ \cite[\S52.4, pp. 850]{Goldman2008}.
	\item {\tt get\_incident\_edges($v_{u}$)}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \cite[\S13.1.1, pp. 599]{Goodrich2011}
		\item \cite[\S52.5, pp. 851]{Goldman2008}
		\end{enumerate}
	\item {\tt depth\_first\_search(string type)} returns a DFS ordering, which is one of the following DFS-based vertex orderings (preordering, postordering, or reverse postordering) \cite{WikipediaContributors2018a51}. \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item (May) require open addressing mapping for implementing DFS \cite[\S53, pp. 857]{Goldman2008}.
		\end{enumerate}
	\item {\tt breadth\_first\_search(string type)} returns a BFS ordering \cite{WikipediaContributors2019}.\vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item (May) require a queue (FIFO) for implementing BFS \cite[\S53, pp. 857]{Goldman2008}.
		\end{enumerate}
	\item Optional methods: \vspace{-0.2cm}
		\begin{enumerate} %\itemsep -2pt
		\item {\tt boolean is\_multigraph()} returns boolean {\tt True} if the graph is a multigraph. Else, returns boolean {\tt False} \cite[\S52.4, pp. 849]{Goldman2008}.
		\item {\tt boolean set\_as\_multigraph(boolean mgraph)}, where the boolean flag {\tt mgraph} indicates if the graph is a multigraph; if {\tt mgraph} is true, the graph is a multigraph; else, the graph is not a multigraph.
		\item {\tt has\_cycles()} returns boolean {\tt True} if the graph $G$ has cycles; else, it returns boolean {\tt False} \cite[\S52.4, pp. 850]{Goldman2008}.
		\item {\tt is\_cycle($E_{cycle}$)} returns boolean {\tt True} if graph $G$ contains the cycle $E_{cycle}$; else, it returns boolean {\tt False} \cite[\S52.4, pp. 850]{Goldman2008}.
		\item {\tt get\_cycle()} \cite[\S52.4, pp. 850]{Goldman2008}: Not considered, since a graph can have multiple cycles.
		\end{enumerate}
	\item Variables: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item set\_of\_connected\_components \cite[\S53, pp. 857]{Goldman2008}.
		\item set\_of\_cycles
		\item Ignore these variables: \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item DFS vertex ordering \cite[\S53, pp. 857]{Goldman2008}, since there exists different types of DFS-based vertex ordering (preordering, postordering, or reverse postordering) \cite{WikipediaContributors2018a51}
			\end{enumerate}
		\end{enumerate}
	\end{enumerate}
\item {\bf Vertex class}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item {\tt is\_incident\_edge($e_{i}$)} \cite[\S13.1.1, pp. 599]{Goodrich2011}.
	\item {\tt get\_incident\_edges()}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \cite[\S13.1.1, pp. 599]{Goodrich2011}
		\item \cite[\S52.5, pp. 851]{Goldman2008}
		\end{enumerate}
	\item {\tt is\_adjacent\_vertex($v_{v}$)} \cite[\S13.1.1, pp. 599]{Goodrich2011}
	\end{enumerate}
\item {\bf Edge class}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item {\tt get\_endpoints()} \cite[\S14.1.1, pp. 626]{Goodrich2013}. Or, name it {\tt get\_end\_vertices()} \cite[\S13.1.1, pp. 599]{Goodrich2011}.
	\item {\tt is\_adjacent\_edge($e_{i}$)} \cite[\S13.1.1, pp. 599]{Goodrich2011}. If the one of the endpoints of this edge is one of the endpoints on edge $e$, this edge is adjacent to edge $e$.
	\item {\tt is\_incident\_on\_vertex($v_{u}$)} \cite[\S13.1.1, pp. 599]{Goodrich2011}.
	\item For two-endpoint edges, {\tt is\_opposite\_vertex($v_{u}$)} \cite[\S13.1.1, pp. 599]{Goodrich2011}.
	\item For two-endpoint edges, {\tt get\_opposite\_vertex($v_{u}$)} \cite[\S13.1.1, pp. 599]{Goodrich2011} \cite[\S14.1.1, pp. 626]{Goodrich2013}.
	\item {\tt is\_incident\_on($v_{u}$)} \cite[\S13.1.1, pp. 599]{Goodrich2011}
	\end{enumerate}
\end{enumerate}

Common functions that need to be implemented in {\bf directed graph} data structures; they are instance methods, unless indicated otherwise (as static methods):
\begin{enumerate}
\item {\bf Graph class}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item {\tt is\_path($e_{set}$)}, where $e_{set}$ is a set of edges (or 2-tuples of vertices), and check if this ordered list/set of edges follows a sequence.
	\item {\tt get\_list\_of\_outgoing\_edges($v_{u}$)} returns a list of outgoing edges of vertex $v_{u}$ \cite[\S52.4, pp. 849; \S52.5, pp. 851]{Goldman2008}.
	\item {\tt get\_list\_of\_incoming\_edges($v_{u}$)} returns a list of incoming edges of vertex $v_{u}$ \cite[\S52.4, pp. 849; \S52.5, pp. 851]{Goldman2008}.
	\item {\tt get\_strongly\_connected\_components()} returns a set of strongly connected components, where each strongly connected component is defined by a set of vertices \cite[\S52.4, pp. 850]{Goldman2008}.: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item (May) require open addressing for implementing the algorithm/heuristic to search for strongly connected components \cite[\S53, pp. 857]{Goldman2008}.
		\end{enumerate}
	\item {\tt add\_strongly\_connected\_components()} adds a strongly connected component (defined by a set of vertices) to the set of strongly connected components stored by the graph. %\cite[\S52.4, pp. 850]{Goldman2008}.
	\item {\tt get\_number\_of\_strongly\_connected\_components()} returns the number of strongly connected components in the graph $G$ \cite[\S52.4, pp. 850]{Goldman2008}.
	\item {\tt get\_topological\_order()} returns an ordered set of vertices representing the graph $G_{DAG}$ traversal using topological sort \cite[\S52.4, pp. 850]{Goldman2008}. If  $G_{DAG}$ is not a directed acyclic graph (DAG), throw a {\tt GraphException}. \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item (May) require circular array to implement topological sort \cite[\S53, pp. 857]{Goldman2008}.
		\end{enumerate}
	\item {\tt get\_shortest\_path\_between\_vertices($v_{u}, v_{v}$)} returns the shortest path from vertex $v_{u}$ to vertex $v_{v}$ \cite[\S52.4, pp. 850]{Goldman2008}.
	\item {\tt get\_set\_of\_shortest\_paths\_from\_vertex($v_{u}$)} returns the set of shortest paths from vertex $v_{u}$ to each reachable vertex $v_{i}$ (from $v_{u}$), such that a path from $v_{u}$ to $v_{i}$ exists, $\forall i \in$ set of paths from $v_{u}$ \cite[\S52.4, pp. 850]{Goldman2008}.
	\item {\tt get\_outgoing\_edges($v_{u}$)} \cite[\S52.5, pp. 851]{Goldman2008}
	\item {\tt get\_incoming\_edges($v_{u}$)} \cite[\S52.5, pp. 851]{Goldman2008}
	\item {\tt depth\_first\_search(string type)} returns a DFS ordering, which is one of the following DFS-based vertex orderings (preordering, postordering, or reverse postordering) \cite{WikipediaContributors2018a51}.\vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item (May) require open addressing mapping for implementing DFS \cite[\S53, pp. 857]{Goldman2008}.
		\end{enumerate}
	\item {\tt breadth\_first\_search(string type)} returns a BFS ordering \cite{WikipediaContributors2019}. \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item (May) require a queue (FIFO) for implementing BFS \cite[\S53, pp. 857]{Goldman2008}.
		\end{enumerate}
	\item Optional methods: \vspace{-0.2cm}
		\begin{enumerate} %\itemsep -2pt
		\item {\tt boolean is\_multigraph()} returns boolean {\tt True} if the graph is a multigraph. Else, returns boolean {\tt False} \cite[\S52.4, pp. 849]{Goldman2008}. 
		\item {\tt boolean set\_as\_multigraph(boolean mgraph)}, where the boolean flag {\tt mgraph} indicates if the graph is a multigraph; if {\tt mgraph} is true, the graph is a multigraph; else, the graph is not a multigraph.
		\item {\tt has\_cycles()} returns boolean {\tt True} if the graph $G$ has cycles; else, it returns boolean {\tt False} \cite[\S52.4, pp. 850]{Goldman2008}.
		\item {\tt is\_cycle($E_{cycle}$)} returns boolean {\tt True} if graph $G$ contains the cycle $E_{cycle}$; else, it returns boolean {\tt False} \cite[\S52.4, pp. 850]{Goldman2008}.
		\item {\tt get\_cycle()} \cite[\S52.4, pp. 850]{Goldman2008}: Not considered, since a graph can have multiple cycles.
		\end{enumerate}
	\item Variables: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item set\_of\_strongly\_connected\_components \cite[\S53, pp. 857]{Goldman2008}.
		\item set\_of\_directed\_cycles \cite[\S53, pp. 857]{Goldman2008}.
		\item ordered set of vertices representing the graph $G_{DAG}$ traversal using topological sort \cite[\S52.4, pp. 850; \S53, pp. 857]{Goldman2008}. Can be omitted.
		\item Ignore these variables: \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item DFS vertex ordering \cite[\S53, pp. 857]{Goldman2008}, since there exists different types of DFS-based vertex ordering (preordering, postordering, or reverse postordering) \cite{WikipediaContributors2018a51}
			\end{enumerate}
		\end{enumerate}
	\end{enumerate}
\item {\bf Vertex class}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item {\tt get\_outgoing\_edges()} \cite[\S52.5, pp. 851]{Goldman2008}
	\item {\tt is\_outgoing\_edge($e_{i}$)}
	\item {\tt get\_incoming\_edges()} \cite[\S52.5, pp. 851]{Goldman2008}
	\item {\tt is\_incoming\_edge($e_{i}$)}
	\item {\tt get\_tail\_vertex()}
	\item {\tt get\_tail\_vertices()} for directed hypergraphs
	\item {\tt is\_adjacent\_to\_destn\_vertex($v_{v}$)}
	\item {\tt is\_adjacent\_from\_src\_vertex($v_{v}$)}
	\end{enumerate}
\item {\bf Edge class}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item {\tt get\_head\_vertex()}, or {\tt get\_src\_vertex()}
	\item {\tt get\_head\_vertices()}, or {\tt get\_src\_vertices()}, for directed hypergraphs
	\item {\tt get\_tail\_vertex()}, {\tt get\_destn\_vertex()}
	\item {\tt get\_tail\_vertices()}, or {\tt get\_destn\_vertices()}, for directed hypergraphs
	\item For two-endpoint edges, {\tt is\_opposite\_vertex($v_{u}$)} \cite[\S13.1.1, pp. 599]{Goodrich2011}. {\it This is pretty useless.}
	\item {\tt is\_adjacent\_edge($e_{i}$)} \cite[\S13.1.1, pp. 599]{Goodrich2011}. That is, determine if the destination vertex of this edge is the source vertex for $e_{i}$; if they are, they are adjacent.
	\item {\tt is\_incident\_from\_vertex($v_{u}$)} \cite[\S13.1.1, pp. 599]{Goodrich2011}. Is current edge incident from $v_{u}$? Basically, this is equivalent to {\tt is\_head\_vertex($v_{u}$)} (or, {\tt is\_src\_vertex($v_{u}$)}).
	\item {\tt is\_incident\_to\_vertex($v_{v}$)} \cite[\S13.1.1, pp. 599]{Goodrich2011}. Is current vertex incident to $v_{v}$? Basically, this is equivalent to {\tt is\_tail\_vertex($v_{v}$)} (or, {\tt is\_destn\_vertex($v_{v}$)}).
	\item 
	%\item {\tt get\_endpoints()}. Or, name it {\tt get\_end\_vertices()} \cite[\S13.1.1, pp. 599]{Goodrich2011}. {\it This is pretty useless.}
	\end{enumerate}
\end{enumerate}



Solvers for the following problems (or to perform the following functions) regarding: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item {\bf graph traversal}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item {\bf breadth-first search}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Breadth-first_search	}
		\item Also, see {\bf BFS ordering}: \url{https://en.wikipedia.org/wiki/Breadth-first_search}
		\item Used for logic simulation, so that I can propagate values from one clock cycle to the next correctly. This assumes that the clock cycle is chosen as the minimum time period for the active/inactive pulse of the clock signal. See {\it Wikipedia}'s entry on duty cycle for vocabulary terms to describe the duty cycle of the clock signal as the ratio of the pulse width (or pulse active time) to the total period of the signal; reference \url{https://en.wikipedia.org/wiki/Duty_cycle}.
		\item \cite[\S53.4]{Goldman2008}
		\item \cite[\S22.2]{Cormen2009}
		\item \cite[\S13.3--\S13.4]{Goodrich2011}
		\item \cite[\S14.3.3]{Goodrich2013}
		\end{enumerate}
	\item {\bf depth-first search}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Depth-first_search}
		\item {\bf iterative deepening search}, or more specifically {\bf iterative deepening depth-first search (IDS or IDDFS)}: \url{https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search}
		\item \cite[\S53.5]{Goldman2008}
		\item \cite[\S22.3]{Cormen2009}
		\item \cite[\S13.3--\S13.4]{Goodrich2011}
		\item \cite[\S14.3.1--\S14.3.2]{Goodrich2013}
		\end{enumerate}
	\item {\bf graph factorization}: \url{???}
	\item References: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Graph_theory}
		\end{enumerate}
	\end{enumerate}
\item {\bf graph coloring}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item {\bf vertex coloring}
	\item {\bf edge coloring}: \url{https://en.wikipedia.org/wiki/Edge_coloring}
	\item {\bf four color theorem}, or the {\bf four color map theorem}: \url{https://en.wikipedia.org/wiki/Four_color_theorem}
	\item References: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Graph_coloring}
		\item \cite{Chartrand2009}
		\end{enumerate}
	\end{enumerate}
\item {\bf routing problems}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item {\bf shortest path problem}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item {\bf Dijkstra's algorithm}: \url{https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm}
		\item {\bf Bellman-Ford algorithm} (or, {\bf Bellman-Ford-Moore algorithm}): \url{https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm}
		\item {\bf Ford-Fulkerson algorithm (FFA)}, or {\bf Ford-Fulkerson method}: \url{https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm}
		\item {\bf Categorize solutions} into those for {\bf directed graphs} and {\bf undirected graphs}. Also, determine solutions for common variants of the problem.
		\item \url{https://en.wikipedia.org/wiki/Shortest_path_problem}
		\item \cite[\S55.2]{Goldman2008} references standard algorithms to find the shortest path.
		\item In addition, \cite[\S55.3]{Goldman2008} suggests using the in-tree data structure to represent the shortest path tree.
		\item \cite[\S24--\S25]{Cormen2009}
		\item \cite[\S6]{Cormen2013}
		\item \cite[\S13.5]{Goodrich2011}
		\item \cite[\S14.6]{Goodrich2013}
		\end{enumerate}
	\item {\bf longest path problem}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item Note that the difficulty of the problem (in terms of {\bf computational time complexity}) is different for different types of graphs: \vspace{-0.1cm}
			\begin{itemize} \itemsep -1pt
			\item E.g., for {\bf undirected graphs}, it is {\bf NP-hard}, while {\bf linear time solutions} exist for {\bf directed acyclic graphs (DAGs)}.
			\end{itemize}
		\item \url{https://en.wikipedia.org/wiki/Longest_path_problem}
		\item \cite[\S5, pp. 80--85]{Cormen2013} covers longest path in a DAG.
		\end{enumerate}
	\item {\bf minimum spanning tree}: \vspace{-0.2cm}
		\begin{itemize} \itemsep -2pt
		\item \item {\bf Prim-Jarn{\'{i}}k algorithm}: \vspace{-0.1cm}
			\begin{itemize} \itemsep -1pt
			\item Also, known as: \vspace{-0.1cm}
				\begin{itemize} \itemsep -1pt
				\item {\bf Prim's algorithm}
				\item {\bf Jarnk's algorithm}
				\item {\bf Prim-Dijkstra algorithm}
				\item {\bf DJP algorithm}
				\end{itemize}
			\item \url{https://en.wikipedia.org/wiki/Prim%27s_algorithm}
			\end{itemize}
		\item {\bf Kruskal's algorithm}: \url{https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}
		\item \url{https://en.wikipedia.org/wiki/Minimum_spanning_tree}
		\item \cite[\S23]{Cormen2009}
		\item \cite[\S13.6]{Goodrich2011}
		\item \cite[\S14.7]{Goodrich2013}
		\end{itemize}
	\item {\bf Steiner tree}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item {\bf rectilinear minimum Steiner tree (RMST)} problem: \url{https://en.wikipedia.org/wiki/Rectilinear_Steiner_tree}
		\item \url{https://en.wikipedia.org/wiki/Steiner_tree_problem}
		\end{enumerate}
	\item {\bf traveling salesperson problem} (NP-hard): \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item {\bf nearest neighbor algorithm}: \vspace{-0.1cm}
			\begin{itemize} \itemsep -1pt
			\item \url{https://en.wikipedia.org/wiki/Nearest_neighbour_algorithm}
			\item This is different from the k-nearest neighbors algorithm ($k$-NN); see \url{https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm}.
			\end{itemize}
		\item \url{https://en.wikipedia.org/wiki/Travelling_salesman_problem}
		\end{enumerate}
	\item {\bf strongly connected components (for directed graphs)}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Strongly_connected_component}
		\item See description in \S\ref{ssec:DirectedGraphsAndDirectedAcyclicGraphs} regarding algorithms (and data structures) associated with directed graphs.
		\item \cite[\S B.4, pp. 1170-1171]{Cormen2009}
		\end{enumerate}
	\item {\bf connected components (for undirected graphs)}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Connected_component_(graph_theory)}
		\item \cite[\S B.4, pp. 1170]{Cormen2009}
		\end{enumerate}
	\end{enumerate}
\item {\bf network flow}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item {\bf max-flow min-cut theorem}: \url{https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem}
	\item {\bf minimum-cost flow problem (MCFP)}: \url{https://en.wikipedia.org/wiki/Minimum-cost_flow_problem}
	\item {\bf maximum flow problems}: \url{https://en.wikipedia.org/wiki/Maximum_flow_problem}
	\item {\bf circulation problem}: \url{https://en.wikipedia.org/wiki/Circulation_problem}
	\item References: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item {\bf Flow network} (or {\bf transportation network}): \url{https://en.wikipedia.org/wiki/Flow_network}
		\item 
		\item {\it maximum flow}
			\begin{itemize}
			\item \cite[\S26]{Cormen2009}
			\end{itemize}
		\end{enumerate}
	\end{enumerate}
\item {\bf graph partitioning}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item {\bf force-directed graph partitioning}
	\item {\bf min-cut graph partitioning}
	\item References: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Connectivity_(graph_theory)}
		\end{enumerate}
	\end{enumerate}
\item {\bf graph-based floorplanning/placement}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item use {\bf constraint graphs} for {\bf graph-based floorplanning/placement}
	\item References: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Constraint_graph_(layout)}
		\end{enumerate}
	\end{enumerate}
\item {\bf covering problems}: %\vspace{-0.3cm}
	\begin{enumerate} %\itemsep -2pt
	\item In graph theory, ``{\bf covering problems} are specific instances of {\bf subgraph-finding problems}''; see \url{https://en.wikipedia.org/wiki/Graph_theory}
	\item {\bf Set cover problem}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Set_cover_problem}
		\item {\bf hitting set problem}
		\end{enumerate}
	\item {\bf Vertex cover problem}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Vertex_cover}
		\item ``A vertex cover is a set of vertices that includes at least one endpoint of each edge in the graph'' \cite{WikipediaContributors2017a11}
		\item ``A vertex cover of a graph is a set of vertices such that each edge of the graph is incident to at least one vertex [in] the set.'' Reference: \url{https://en.wikipedia.org/wiki/Vertex_cover}.
		\end{enumerate}
	\item {\bf edge cover problem}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Edge_cover}
		\end{enumerate}
	\item Related problems: %\vspace{-0.2cm}
		\begin{enumerate} %\itemsep -2pt
		\item {\bf clique problem}: \url{https://en.wikipedia.org/wiki/Clique_problem}
		\item {\Large  {\bf Covering/packing-problem pairs}, or {\bf covering/packing dualities}}: \url{https://en.wikipedia.org/wiki/Linear_programming#Covering/packing_dualities}
		\item {\bf Packing problems}: \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item \url{https://en.wikipedia.org/wiki/Packing_problems}
			\item {\bf Maximum set packing}: \url{https://en.wikipedia.org/wiki/Set_packing}
			\item {\bf Maximum matching} (not graph matching), or {\bf independent edge set}: \url{https://en.wikipedia.org/wiki/Matching_(graph_theory)}
			\item {\bf independent set problem}, and {\bf maximum independent set}: \url{https://en.wikipedia.org/wiki/Independent_set_(graph_theory)}
			\end{enumerate}
		\item {\bf Reconstruction conjecture}: \vspace{-0.1cm}
			\begin{itemize} \itemsep -1pt
			\item ``Informally, the {\bf reconstruction conjecture} in graph theory says that graphs are determined uniquely by their subgraphs.''
			\item \url{https://en.wikipedia.org/wiki/Reconstruction_conjecture}
			\end{itemize}
		\end{enumerate}
	\item References: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Covering_problems}
		\end{enumerate}
	\end{enumerate}
\item graph matching: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \url{https://en.wikipedia.org/wiki/Graph_matching}
	\end{enumerate}
\item {\bf graph decomposition problems}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item {\bf arboricity}: \url{https://en.wikipedia.org/wiki/Arboricity}
	\item {\bf cycle double cover}: \url{https://en.wikipedia.org/wiki/Cycle_double_cover}
	\item {\bf graph factorization}: \url{https://en.wikipedia.org/wiki/Graph_factorization}
	\item : \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item 
		\end{enumerate}
	\item References: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Graph_theory}
		\end{enumerate}
	\end{enumerate}
\item {\bf closure problem}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \url{https://en.wikipedia.org/wiki/Closure_problem}
	\end{enumerate}
\item {\bf spectral graph theory}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item ``In mathematics, {\bf spectral graph theory} is the study of the properties of a graph in relationship to the characteristic polynomial, eigenvalues, and eigenvectors of matrices associated with the graph, such as its adjacency matrix or Laplacian matrix.''
	\item References: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Spectral_graph_theory}
		\item \cite{Spielman2007}
		\item \cite{Brouwer2012}
		\item \cite{Cvetkovic2010}
		\item \cite{vanMieghem2011}
		\item \cite{Thornton2001}
		\item \cite{Gross2004}
		\end{enumerate}
	\end{enumerate}
\item {\bf probabilistic graphical model} ({\bf PGM}): \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item Also known as: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item {\bf graphical model}
		\item {\bf structured probabilistic model}
		\end{enumerate}
	\item References: \vspace{-0.2cm}
		\begin{enumerate} %\itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Graphical_model}
		\item \cite{Barber2012}
		\item \cite{Bishop2006}
		\item Cowell, Robert G.; Dawid, A. Philip; Lauritzen, Steffen L.; Spiegelhalter, David J. (1999). Probabilistic networks and expert systems. Berlin: Springer. A more advanced and statistically oriented book
		\item Jensen, Finn (1996). An introduction to Bayesian networks. Berlin: Springer.
		\item Pearl, Judea (1988). Probabilistic Reasoning in Intelligent Systems (2nd revised ed.). San Mateo, CA: Morgan Kaufmann. 
		\end{enumerate}
	\end{enumerate}
\item {\bf quantum graph}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item ``In mathematics and physics, a {\bf quantum graph} is a linear, network-shaped structure of vertices connected by bonds (or edges) with a differential or pseudo-differential operator acting on functions defined on the bonds.''
	\item References: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Quantum_graph}
		\item \cite{Lovasz2012}
		\end{enumerate}
	\end{enumerate}
\end{enumerate}





Solvers for the following problems (or to perform the following functions) regarding subgraphs, induced subgraphs, and minors: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item {\bf subgraph isomorphism problem}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item {\bf Find a fixed graph as a subgraph in a given graph}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item ``graph properties are hereditary for subgraphs''\dots\ ``A graph has a property if and only if all its subgraphs also have it''; see \url{https://en.wikipedia.org/wiki/Graph_theory}.
		\item Finding a specific type/kind of maximal subgraph is an NP-complete problem, such as the largest complete subgraph.
		\end{enumerate}
	\item Also, see {\bf subgraph matching}.
	\item {\bf Graph isomorphism}: \url{https://en.wikipedia.org/wiki/Graph_isomorphism}
	\item {\bf Graph isomorphism problem}: \url{https://en.wikipedia.org/wiki/Graph_isomorphism_problem}
	\item \url{https://en.wikipedia.org/wiki/Subgraph_isomorphism_problem}
	\end{enumerate}
\item {\bf Finding induced subgraphs} in a given graph: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item ``graph properties are hereditary'' for induced subgraphs\dots\ ``A graph has a property if and only if all its induced subgraphs also have it''; see \url{https://en.wikipedia.org/wiki/Graph_theory}.
	\item Finding a specific type/kind of {\bf maximal induced subgraph} is an NP-complete problem: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item {\bf Independent set problem}: Finding the largest {\bf edgeless induced subgraph} (or {\bf independent set}); see the following references: \vspace{-0.1cm}
			\begin{itemize} \itemsep -1pt
			\item \url{https://en.wikipedia.org/wiki/Graph_theory}
			\end{itemize}
		\end{enumerate}
	\item {\bf Induced subgraph}: \url{https://en.wikipedia.org/wiki/Induced_subgraph}
	\end{enumerate}
\item {\bf minor containment problem}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item Find a {\bf fixed graph} as a minor of a given graph.
	\item ``A {\bf minor} or {\bf subcontraction of a graph} is any graph obtained by taking a {\bf subgraph} and contracting some (or no) edges''\dots\ ``A graph has a property if and only if all its {\bf minors} [also] have it''
	\item ``[{\bf Minor containment}] is related to graph properties such as planarity.'' See Wagner's Theorem about planar graphs.
	\item References: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Graph_theory}
		\item Graph minor: \url{https://en.wikipedia.org/wiki/Graph_minor}
		\end{enumerate}
	\end{enumerate}
\item {\bf subdivision containment problems}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item ``{\bf Find a fixed graph as a subdivision of a given graph}'': \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item ``A {\bf subdivision} or {\bf homeomorphism} of a graph is any graph obtained by subdividing some (or no) edges.''
		\item ``{\bf Subdivision containment} is related to graph properties such as planarity.'' See Kuratowski's Theorem and the Kelmans-Seymour conjecture about planar graphs.
		\end{enumerate}
	\item References: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Graph_theory}
		\item {\bf Homeomorphism}: \url{https://en.wikipedia.org/wiki/Homeomorphism_(graph_theory)#Subdivision_and_smoothing}
		\end{enumerate}
	\end{enumerate}
\end{enumerate}


Other common topics: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item {\bf network science}: \vspace{-0.3cm}
	\begin{itemize} \itemsep -2pt
	\item \url{https://en.wikipedia.org/wiki/Network_science}
	\item {\bf Interdependent networks}: \url{https://en.wikipedia.org/wiki/Interdependent_networks}
	\item {\bf Modularity} (networks): \url{https://en.wikipedia.org/wiki/Modularity_(networks)}
	\item {\bf Community structure}: \url{https://en.wikipedia.org/wiki/Community_structure}
	\item {\bf Distance} (graph theory): \url{https://en.wikipedia.org/wiki/Distance_(graph_theory)}
	\item {\bf Assortativity}: \url{https://en.wikipedia.org/wiki/Assortativity}
	\item {\bf Degree distribution}: \url{https://en.wikipedia.org/wiki/Degree_distribution}
	\item {\bf Centrality}: \url{https://en.wikipedia.org/wiki/Centrality#Closeness_centrality}
	\item {\bf Betweenness centrality}: \url{https://en.wikipedia.org/wiki/Betweenness_centrality}
	\end{itemize}
\end{enumerate}



Other problems and types of graphs, not of comparable importance: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item nearest neighbor graph (NNG): \url{https://en.wikipedia.org/wiki/Nearest_neighbor_graph}
\end{enumerate}



The {\it GraphException} class is a child class of the Exception class. See \url{https://github.com/eda-ricercatore/gulyas-scripts/blob/master/notes/python.md#exception-handling} for information about implementing the {\it GraphException} class \cite[\S52.4, pp. 849]{Goldman2008}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Directed Graphs, and Directed Acyclic Graphs}
\label{ssec:DirectedGraphsAndDirectedAcyclicGraphs}


Notes on directed graphs (digraphs), and directed acyclic graphs (DAGs): \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item Functions to implement, and solves to solve the following problems: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item transitive closure: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \cite[\S13.4.2]{Goodrich2011}
		\cite[\S14.4]{Goodrich2013}
		\end{enumerate}
	\item For DAGs: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item {\bf topological sort}: \vspace{-0.1cm}
			\begin{itemize} \itemsep -1pt
			\item Also known as: {\bf topological sorting}, or {\bf topological ordering}
			\item \url{https://en.wikipedia.org/wiki/Topological_sorting}
			\item \cite[\S53.6]{Goldman2008}
			\item \cite[\S22.4]{Cormen2009}
			\item \cite[\S5, pp. 75--80]{Cormen2013}
			\item \cite[\S14.5.1]{Goodrich2013}
			\end{itemize}
		\item {\bf strongly connected components}:
			\begin{itemize}
			\item \cite[\S22.5]{Cormen2009}
			\end{itemize}
		\item {\bf precedence graphs}, {\bf conflict graphs}, or {\bf serializability graphs}
			\begin{itemize}
			\item ``Used in the context of concurrency control in databases''; see \url{https://en.wikipedia.org/wiki/Precedence_graph}
			\item \cite[\S53.6]{Goldman2008}
			\item \cite[\S52.1, pp 844]{Goldman2008}
			\end{itemize}
		\item algorithms, heuristics, and meta-heuristics to optimize: \vspace{-0.1cm}
			\begin{itemize} \itemsep -1pt
			\item BDDs; see \S\ref{sssec:BinaryDecisionDiagramsBDDs}.
			\item AIGs; see \S\ref{sssec:ANDInverterGraphsAIGs}
			\item MIGs; see \S\ref{sssec:MajorityInverterGraphsMIGs}
			\end{itemize}
		\end{enumerate}
	\end{enumerate}
\end{enumerate}











%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Binary Decision Diagrams (BDDs)}
\label{sssec:BinaryDecisionDiagramsBDDs}


Resources for BDDs: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item \url{https://en.wikipedia.org/wiki/Binary_decision_diagram}
\end{enumerate}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{AND-Inverter Graphs (AIGs)}
\label{sssec:ANDInverterGraphsAIGs}




Resources for AIGs: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item \url{https://en.wikipedia.org/wiki/And-inverter_graph}
\end{enumerate}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Majority-Inverter Graphs (MIGs)}
\label{sssec:MajorityInverterGraphsMIGs}



Resources for MIGs: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item 
\end{enumerate}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Undirected Graphs}
\label{ssec:UndirectedGraphs}

Notes about undirected graphs are available in the subsection on graph theory, \S\ref{ssec:GraphTheory}.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Resources for Graphs}
\label{ssec:ResourcesForGraphs}

Resources for graphs: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item ``The Stanford GraphBase: A Platform for Combinatorial Computing'': \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite{Knuth1993}
	\item \url{https://www-cs-staff.stanford.edu/~knuth/sgb.html}
	\end{enumerate}
\item {\bf Graph analysis} using techniques from {\bf linear algebra}, or {\bf linear algebra in graph theory}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item See references \cite{Bapat2014,Brouwer2012,Bapat2010,Hogben2007,Biggs1974}. Also, see \cite{Lovasz2014}.
	\item E.g., ``the vertex space of a graph is [represented by] the vector space'' that has a set of basis vectors that correspond to the vertices of the graph \cite{WikipediaContributors2017a11}
	\item For edge space and vector space, see \url{https://en.wikipedia.org/wiki/Edge_space}.
	\end{enumerate}
\item {\it Wikipedia}: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \url{https://en.wikipedia.org/wiki/List_of_algorithms#Graph_algorithms}
	\item {\bf Gallery of named graphs}: \url{https://en.wikipedia.org/wiki/Gallery_of_named_graphs}
	\item {\bf List of graph theory topics}: \url{https://en.wikipedia.org/wiki/List_of_graph_theory_topics}
	\item {\bf Glossary of graph theory terms}: \url{https://en.wikipedia.org/wiki/Glossary_of_graph_theory_terms}
	\item : \url{}
	\item : \url{}
	\item : \url{}
	\item : \url{}
	\item : \url{}
	\item : \url{}
	\item : \url{}
	\item : \url{}
	\item : \url{}
	\item {\bf Graph algebra}: \url{https://en.wikipedia.org/wiki/Graph_algebra}
	\item {\bf Algebraic graph theory}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item \url{https://en.wikipedia.org/wiki/Algebraic_graph_theory}
		\item Can use linear algebra (includes spectral graph theory), group theory, and the study of graph invariants.
		\end{enumerate}
	\end{enumerate}
\end{enumerate}











